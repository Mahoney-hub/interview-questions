export const questions = [
    {
        id: 1,
        question: 'Отличие React от Angular',
        answer: 'React-это библиотека т.к нужно доустанавливать Роутинг, Редакс  и т.д по выбору. Angular-фреймворк, т.к доустанавливать ничего не надо.'
    },
    {
        id: 2,
        question: 'Зачем нужен React?',
        answer: 'React-нужен для эффективной отрисовки страницы приложения, для этого у него есть Виртуальный DOM. Виртуальный ДОМ  сравнивается с ДОМом Браузера, если есть различия –заменяется. Перерисовка происходит не всей страницы, а конкретного узла, в котором найдены различия.'
    },
    {
        id: 3,
        question: 'Что такое объект?',
        answer: 'Объект – это ассоциативный массив с рядом дополнительных возможностей. Хранит свойства пары ключ:значение'
    },
    {
        id: 4,
        question: 'Что такое функция?',
        answer: 'Функция-это объект, т.к имеет свои встроенные свойства: name, constructor и тд. Функция - это код, который можно использовать неоднократно'
    },
    {
        id: 5,
        question: 'Что такое чистая функция?',
        answer: 'Чистая функция - не имеет бизнес-логики, не работает с ДОМ, не посылает запросы на сервер (сайд эффект), просто получает данные(пропсы) и отображает их. Side Effect-запрос на сервер, работа с DOM, изменение параметров функции. Принципы чистой функции:  Иммутабельность- функция не имеет права изменить данные, которые в нее пришли. Идемпотентность (“не дай бог” если трудно запомнить)- дает один и тот же результат при каждом вызове. Детерминированность-т.е. результат предсказуем.'
    },
    {
        id: 6,
        question: 'Что такое компонент?',
        answer: 'Компонент-это функция принимающая пропсы и возвращающая jsx разметку. Состоит из двух частей - над return код, функционал, снизу разметка.'
    },
    {
        id: 7,
        question: 'Методы map и filter',
        answer: 'Возвращают новый массив: map, filter. Map возвращает ровно столько элементов сколько в него пришло из массива, если по каким либо причинам данных для отрисовки последнего элемента массива не будет, то в последнем выдаст undefined. forEach-работает со «старым массивом».Find не изменяет массив, для которого он был вызван.'
    },
    {
        id: 8,
        question: 'SPREAD оператор',
        answer: 'SPREAD оператор - с его помощью обычно копируют или сливают массивы.'
    },
    {
        id: 9,
        question: 'Что такое Литерал?',
        answer: 'Литерал – это запись в нашем коде. Напр. 10 или "строка" или объект {a:10, b:20}. Литерал объекта — это список {ключ: «значение»}  в фигурных скобках.'
    },
    {
        id: 10,
        question: 'Что такое Колбэк-функция (или обратный вызов)?',
        answer: 'Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, и от туда вызывается.'
    },
    {
        id: 11,
        question: 'Отличие элемента от компоненты',
        answer: 'Отличие элемента от компоненты: элемент - это что-то простейшее (к примеру, тэг h1 В который завернута строка h1), а компонент - это часть целого, т.е. функция, которая возвращает элементы.'
    },
    {
        id: 12,
        question: 'Что такое Стор?',
        answer: 'Стор-это глобальный объект, в котором находится state, getState, dispatch. Методы объекта Стора: GetState -дай стейт. Dispatch-вызывает изменения в стейте.'
    },
    {
        id: 13,
        question: 'Что такое Props?',
        answer: 'Props-это объект (вспомни как мы ее типизируем).'
    },
    {
        id: 14,
        question: 'Что такое NodeJS?',
        answer: 'NodeJS- это программа, которая находится на сервере (вместо браузера) и в нем работает JS. Браузер и NodeJS используют один и тот же движок v8-поэтому обоих воспринимает JS.'
    },
    {
        id: 15,
        question: 'Что такое GIT?',
        answer: 'GIT- система контроля версий.'
    },
    {
        id: 16,
        question: 'Что такое Замыкание?',
        answer: 'Замыкание- это способность функции получать доступ к данным ее внешнего лексического окружения (область видимости). Локальная зона видимости-внутри функции, глобальная зона видимости-для всего проекта. Замыкание противоречит чистой функции т.к. не явно может изменять данные. В отличие от функций объявленных с помощью let/const, классические функции (НЕ СТРЕЛОЧНЫЕ) полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение (с загрузки страницы). Замыкание используется в санках(Thunk).'
    },
    {
        id: 17,
        question: 'Что такое Хуки?',
        answer: 'Хуки — это функции, с помощью которых вы можете «подцепиться» к состоянию и методам жизненного цикла React из функциональных компонентов. Правила использования hook-ов: нельзя использовать в  массивах, условиях, циклах-если там будет меняться кол-во элементов. UseState- возвращает значение с состоянием и функцию для его обновления. Работает асинхронно.'
    },
    {
        id: 18,
        question: 'Что такое CRUD?',
        answer: 'CRUD-Create(POST-запрос на сервер) Read(GET-запрос на сервер) Update Delete. В ТудуЛисте мы реализуем CRUD.'
    },
    {
        id: 19,
        question: 'Что такое Куки?',
        answer: 'Это текстовый документ по принципу ключ-значение: key: value. Хранятся в браузере (на серваке не хранятся!) Сколько сайтов, столько и файлов. И реквест и респонс с сервера вносят изменения в файл куки.  Обычно используются для проверки паролей. При регистрации на сайте пароль хешируется. Один хеш пароля остается  на компьютере, второй уходит на сервер. При входе на сайт, два хеша сравниваются. Также в куке хранится время жизни-сколько будет хранится логин-пароль. Скажем запоминает на 2 недели, а далее нужно вводить по новой.'
    },
    {
        id: 20,
        question: 'Чем отличается localStorage от sessionStorage?',
        answer: 'Могут хранить пары ключ-значение в браузере. localStorage-бесконечно, или можно настроить. SessionStorage-до выключения браузера.'
    },
    {
        id: 21,
        question: 'Что такое SOLID(расширенные правила ООП)?',
        answer: 'Single Responsibility-принцип единственной ответственности: одна функция-одна задача, Open/Close-расширяем функционал за счет написания новых классов/компонент а не догружая старый класс/компоненту(открыт для раширения, закрыт для модификации) Liskov-принцип Барбары Лиски: необходимо, чтобы класс-потомок был способен обрабатывать те же запросы, что и родитель, и выдавать тот же результат. К  примеру: класс-родитель подаёт кофе (в любых видах), значит, для класса-потомка приемлемо подавать капучино (разновидность кофе), но неприемлемо подавать воду. Interface-инкапсуляция. Несколько специализированных интерфейсов лучше, чем один универсальный. Depency Invertion- принцип инверсии зависимостей. Модули верхнего уровня не должны зависеть от нижнего-т.е. логика (верхний уровень не должна зависеть от деталей-т.е. от нижнего уровня)'
    },
    {
        id: 22,
        question: 'Что такое ХОК',
        answer: 'Hight Order Component: React.memo. Хок-это функция, которой обворачиваем компоненту (React.memo). Смотрит на входящие пропсы-и принимает на их основании решение : перерисовывать или не перерисовывать.'
    },
    {
        id: 23,
        question: 'Что такое TDD?',
        answer: 'это разработка при помощи тестирования.  Вначале тест, а потом уже код. Для чего это нужно: делаем кнопку-все ок, но пять кнопок сделанные за год до этого перестают работать, и мы даже не узнаем об этом…'
    },
    {
        id: 24,
        question: 'Что такое DNS?',
        answer: 'Domain Name System. Вся сеть интернет состоит из DNS серверов. Это распределители (как удлинитель из которого тянутся сотни проводов), и одновременно справочники. Мы на компьютере набираем Kamasutra.com-наш запрос идет на ближайший DNS сервер, от него к другому, пока скажем мы не свяжемся с сервером, который находится в США. DNS сервер сравнивает наше текстовое название сайта Kamasutra.com с IP адресом(192.172.333.444) и направляет наш запрос в нужную сторону.'
    },
    {
        id: 25,
        question: 'Что такое UseEffect?',
        answer: 'Хук, который следит за жизненным циклом функции: включилась, отработала,  и очистилась, чтобы не занимать ресурсы.  Сработает после отрисовки страницы, чтобы не тормозить приложение. Обычно берет значение из UseState единожды и использует его (замыкание). Первым параметром принимает колбэк, в котором мы будем делать сайдЭффекты, а вторым параметром принимает массив зависимостей. Если не поставить вторым параметром []-то он будет каждый раз вызываться. Пустой []-отработает единожды, когда компонента вмонтируется в DOM. Если укажем зависимость в массиве, скажем [state], то как только произойдут изменения в стейте, тут же сработает. '
    },
    {
        id: 26,
        question: 'Что такое useMemo, useCallBack(обворачиваем колбэк)?',
        answer: 'Эти хуки оптимизируют  перерисовку узлов, путем запоминания функции.'
    },
    {
        id: 27,
        question: 'Что такое Редюсер?',
        answer: 'Редюсер- это чистая функция, принимает стейт и экшен. Экшен говорит как преобразовать стейт или вернуть стейт без изменений. CombineReducer-объединяет редюсеры (находится в сторе)-возвращает редюсер.'
    },
    {
        id: 28,
        question: 'Что такое Action?',
        answer: 'Action - объект, который как минимум имеет свойство  "type".'
    },
    {
        id: 29,
        question: 'Что такое Redux?',
        answer: 'Redux –это стейт менеджер (хранитель стейта).'
    },
    {
        id: 30,
        question: 'Итого: Пользователь что-то сделал и что потом?',
        answer: 'выполнилась функция - поменялся стейт -вернулся новый JSX - создался новый Виртуал дом (объект) - сравнился при помощи встроенных алгоритмов со старым Витруал домом (объект) - и наконец, происходит перерисовка ДОМа (объект), но не всего, а конкретного узла, где были изменения. Старый Виртуальный Дом удаляется сборщиком мусора т.к. на него больше нет ссылок.'
    },
    {
        id: 31,
        question: 'Отличие стрелочной функции от классической (function declaration)?',
        answer: '1.v8 пробегается по странице дважды. Первый раз собирает все function declaration и var, затем второй проход и выполнение кода. Какая нам разница? Вот какая: на первой строке мы можем вызвать функцию, а на 110 строке прописать  function declaration. Если мы тоже самое проделаем со стрелочной функцией нам выдаст: variable \'newFoo\' used before its declaration.  2. Стрелочная функция не имеет методов call, apply,bind т.к. нет смысла привязывать  this (не создает собственный контекст исполнения, она использует внешний) . 3. Т.к. у стрелочной функции нет своего this, то она не может создавать функции конструкторы.'
    },
    {
        id: 32,
        question: 'Замыкание?',
        answer: 'Замыкание- это способность функции работать с переменными из внешнего лексического окружения (Вызываем функцию, а функция подсасывает переменную, которая не находится в ней).'
    },
    {
        id: 33,
        question: 'HTTP?',
        answer: 'HTTP - протокол передачи данных. Позволяет отправить название сайта(ресурса). HTTPS-его усовершенствованная защищенная версия. Когда шлем запрос через HTTP можно перехватить сигнал WI-FI, украсть куки, и с другого компьютера зайти в чужой аккаунт. HTTPS-в начале меняется секретными ключами (чтобы убедиться, что это не перехват) , а потом шифрует всю информацию исходящую с нашего компьютера. Также сайты получают специальные протоколы безопасности.Типы HTTP/ HTTPS запросов: GET-получить. Можно уточнить запрос если добавить в него query параметры: название сайта? (ставим вопросительный знак и после него пишеи параметры, к примеру) page=100&users=100. POST–отправить/обновить свои данные на сервер. POST-запрос в отличие от GET-запроса защищен, имеет тело. PUT- обновить, как и POST имеет тело.  DELETE-удалить данные, не имеет тела как и GET. '
    },
    {
        id: 34,
        question: 'Thunk?',
        answer: 'Thunk- это функция, которая принимает dispatch, в ней хранятся асинхронные запросы. Вторым параметором (не обязательным) getState(). Dispatch вызывает ThunkCreator-> ThunkCreator вызывает ActionCreator-> ActionCreator благодаря хранящемуся в нем action.type попадает в case Reducera.'
    },
    {
        id: 35,
        question: 'EventLoop?',
        answer: 'EventLoop-это событийный цикл, который выполняет задачи, которые попали к нему (он следит за колСтеком: в начале таски, потом микротаски и в самом конце макротаски). Микротаски-это асинхрон. Макротаски-это асинхрон+ setTimeout  или setInterval.'
    },
    {
        id: 36,
        question: 'Promise?',
        answer: 'Promise- это класс, объект (т.к. всегда можем создать new Promise) в котором при помощи resolve(выполнил обещание) и reject(НЕ выполнил обещание)  хранится асинхронный запрос. У промиса 3 метода, которые мы можем вызвать: then(),catch(),finally(). В эти методы мы кладем колБэк. КолБэк- это вызов функции, который мы кому то передаем, здесь мы передаем вызов промису. Promise может находится в трех состояния (status): pending -ожидание, resolve-выполнен(full-field), reject -не будет выполнен.  .then –т.е затем->находится в состоянии ожидания (). catch-если ошибка то… finally-будет выполнен в любом случае (ошибка или все ок).  then и catch-возвращают промис. '
    },
]
