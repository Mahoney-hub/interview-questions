import {v1} from 'uuid';

export const questionsJS = [
    {
        id: v1(),
        question: 'Для чего нужен JS',
        answer: 'JavaScript используется для того, чтобы делать страницы интерактивными, то есть дать пользователю возможность взаимодействовать с элементами. Когда страницы могут реагировать на какие-то действия, это делает их интереснее.'
    },
    {
        id: v1(),
        question: 'Что такое объект?',
        answer: 'Объект – это ассоциативный массив с рядом дополнительных возможностей. Хранит свойства пары ключ:значение'
    },
    {
        id: v1(),
        question: 'Что такое функция?',
        answer: 'Функция-это объект, т.к имеет свои встроенные свойства: name, constructor и тд. Функция - это код, который можно использовать неоднократно'
    },
    {
        id: v1(),
        question: 'Что такое чистая функция?',
        answer: 'Чистая функция - не имеет бизнес-логики, не работает с ДОМ, не посылает запросы на сервер (сайд эффект), просто получает данные(пропсы) и отображает их. Side Effect-запрос на сервер, работа с DOM, изменение параметров функции. Принципы чистой функции:  Иммутабельность- функция не имеет права изменить данные, которые в нее пришли. Идемпотентность (“не дай бог” если трудно запомнить)- дает один и тот же результат при каждом вызове. Детерминированность-т.е. результат предсказуем.'
    },
    {
        id: v1(),
        question: 'Методы map и filter',
        answer: 'Возвращают новый массив: map, filter. Map возвращает ровно столько элементов сколько в него пришло из массива, если по каким либо причинам данных для отрисовки последнего элемента массива не будет, то в последнем выдаст undefined. forEach-работает со «старым массивом».Find не изменяет массив, для которого он был вызван.'
    },
    {
        id: v1(),
        question: 'SPREAD оператор',
        answer: 'SPREAD оператор - с его помощью обычно копируют или сливают массивы.'
    },
    {
        id: v1(),
        question: 'Что такое Литерал?',
        answer: 'Литерал – это запись в нашем коде. Напр. 10 или "строка" или объект {a:10, b:20}. Литерал объекта — это список {ключ: «значение»}  в фигурных скобках.'
    },
    {
        id: v1(),
        question: 'Что такое Колбэк-функция (или обратный вызов)?',
        answer: 'Колбэк-функция (или обратный вызов) - это функция, переданная в другую функцию в качестве аргумента, и от туда вызывается.'
    },
    {
        id: v1(),
        question: 'Что такое Замыкание?',
        answer: 'Замыкание- это способность функции получать доступ к данным ее внешнего лексического окружения (область видимости). Локальная зона видимости-внутри функции, глобальная зона видимости-для всего проекта. Замыкание противоречит чистой функции т.к. не явно может изменять данные. В отличие от функций объявленных с помощью let/const, классические функции (НЕ СТРЕЛОЧНЫЕ) полностью инициализируются не тогда, когда выполнение доходит до них, а раньше, когда создаётся лексическое окружение (с загрузки страницы). Замыкание используется в санках(Thunk).'
    },
    {
        id: v1(),
        question: 'Promise?',
        answer: 'Promise- это класс, объект (т.к. всегда можем создать new Promise) в котором при помощи resolve(выполнил обещание) и reject(НЕ выполнил обещание)  хранится асинхронный запрос. У промиса 3 метода, которые мы можем вызвать: then(),catch(),finally(). В эти методы мы кладем колБэк. КолБэк- это вызов функции, который мы кому то передаем, здесь мы передаем вызов промису. Promise может находится в трех состояния (status): pending -ожидание, resolve-выполнен(full-field), reject -не будет выполнен.  .then –т.е затем->находится в состоянии ожидания (). catch-если ошибка то… finally-будет выполнен в любом случае (ошибка или все ок).  then и catch-возвращают промис. '
    },
    {
        id: v1(),
        question: 'Отличие стрелочной функции от классической (function declaration)?',
        answer: '1.v8 пробегается по странице дважды. Первый раз собирает все function declaration и var, затем второй проход и выполнение кода. Какая нам разница? Вот какая: на первой строке мы можем вызвать функцию, а на 110 строке прописать  function declaration. Если мы тоже самое проделаем со стрелочной функцией нам выдаст: variable \'newFoo\' used before its declaration.  2. Стрелочная функция не имеет методов call, apply,bind т.к. нет смысла привязывать  this (не создает собственный контекст исполнения, она использует внешний) . 3. Т.к. у стрелочной функции нет своего this, то она не может создавать функции конструкторы.'
    },
    {
        id: v1(),
        question: 'EventLoop?',
        answer: 'EventLoop-это событийный цикл, который выполняет задачи, которые попали к нему (он следит за колСтеком: в начале таски, потом микротаски и в самом конце макротаски). Микротаски-это асинхрон. Макротаски-это асинхрон+ setTimeout  или setInterval.'
    },
]